---
title: 進化的設計
tags: TAGS
---

----
AConversationWithMartinFowler

* http://www.artima.com/intv/evolutionP.html
* by Bill Venners
* 2002年11月18日

* Version:0.8（引用部分の日本語訳を誰か教えてください）
----
{{toc}}

## 計画的設計 vs 進化的設計(Planned versus Evolutionary Design)

'''Bill Venners''': 「設計の終焉?」の中で計画的設計について述べられていますよね。計画的設計とはどういったものでしょうか？

'''Martin Fowler''': 私は計画的設計と進化的設計とを区別しています。計画的設計とは、ソフトウェアを作る際にまず設計を行い、それからコーディングするようなことを指します。計画的設計はUMLダイアグラムの形をとることがあります。システムをサブシステムに分解し、サブシステム間のインターフェイスを定義するものだといえるかもしれません。計画的設計を用いれば、設計とコーディングとの間に明確な「スイッチ」が存在することになります。それぞれのタスクは普通、別々の人間が行います。設計者が設計を行い、開発者がコーディングを行うのです。必ずしも完全に確定したものではないにせよ、設計はほぼ確定したものとして扱われます。設計が優れていれば、コーディング時の変更が少なくなると言ってよいでしょう。

一方、進化的設計では、プログラミングを行いながらゆっくりと設計を進化させていきます。はじめから設計は存在しません。小さな機能をコーディングすることから始め、機能を追加していき、設計を洗練させていくのです。

「設計の終焉?」の中で私は、統制のとれていない状況で進化的設計に出会ってしまい、うまく進化的設計が機能しなかった経験のあるひとが数多くいる、と指摘しました。結局、最後にはでたらめな設計になってしまうんですね。みなさんが計画的設計に引き寄せられてしまう理由のひとつが、これです。

しかし、XPのプラクティスである継続的インテグレーション、テスティング、およびリファクタリングを用いれば、進化的設計はきちんと機能するように思います。計画的設計よりも効果的ではないでしょうか。計画的設計の弱点は、実際に優れた設計を行うことはとても難しいという点です。

'''Bill Venners''': なぜ難しいのでしょうか？

'''Martin Fowler''': 分かりません。交響曲を作曲するのはなぜ難しいのでしょうか？分かりませんね。ただひとつ言えることは、世界中でほんのわずかの人間だけが、それを成すことができる、ということです。これは、前払いの(upfront)設計の問題だと思います。きちんと行うことは、ものすごく難しいことなのです。

興味深いことに、進化的設計の主要な提唱者であるKent BeckやWard Cunninghamなどは、大変優れた設計者です。しかし彼らの結論は、前払いの設計は概してあまりよくないものである、というふうになっています。
彼らは設計をやり過ぎてしまい、不必要で複雑なものまで設計に組み込もうとしていました。必要のないところにまで柔軟性があり、必要なところには柔軟性がないというような設計をしていたのです。
代わりに彼らは、進化的設計が機能するような手法を採用し、いくつかのルールを適用しました。
結果として彼らは、より優れた設計をより早く作り出せるようになりました。
私は80パーセントもの時間が節約できたように思います。
私は、嫌味になるかもしれませんけど、平均よりも遥かに上のスキルを持った設計者ですけども、進化的設計はもっと幅広い方々のお役に立つように思います。

## リファクタリングと前払いの設計(Refactoring and Upfront Design)

'''Bill Venners''': リファクタリングは前払いの設計の役割をどのように変えたのでしょうか？

'''Martin Fowler''': 計画的設計を行ってしまうのは、コードの変更は面倒なものだと思っているからです。コードを変更するときに、何かを壊したり、バグが数多く紛れ込んだりしますからね。でも、ユニットテストを行い、しっかりとしたリファクタリング技術を構築しさえすれば、コードの変更は効率的に行うことができます。欠陥が入り込むことも少なくなるでしょう。

'''Bill Venners''': リファクタリングなどの有効なプラクティスを行う上で、前払いの設計の役割とはどういったものになるのでしょうか？今も前払いの設計を行っていらっしゃいますか？

'''Martin Fowler''': 前払いの設計にもまだ余地があると私は思っています……多くはありませんけどね。Kent BeckやRon Jeffriesなどは、もう使わないと言っていました。まあ、彼らの言い分も間違いではありません。複雑なシステムも、進化的設計で構築することができるのですから。しかし、前払いの設計を使ったほうが早く構築できる場合もあります。ですから私は、必要になるまでデータベースを使わないという考えには賛成できません。私はデータベースをどうするかといったところから設計を始めます。ただし、設計は進化させていきます。

'''Bill Venners''': うまくリファクタリングされたプログラムとうまく設計されたプログラムに違いはあるのでしょうか？

'''Martin Fowler''': 実際にはほとんど同じものでしょう。しかし、重要性という意味では違いがあるかもしれません。「設計」が「分解」に従事しているのです--プログラムをちょうどいい単位に「分解」することが「設計」なのです。
よく分解されていれば、それらを見たり使ったりすることで、設計をどう行えばよいか分かってくるものです。

## コードの不吉な匂い(Bad Smells in Code)

'''Bill Venners''': いつリファクタリングを行えばよいか教えてください。『リファクタリング』の中で「Rather than appealing to some vague notion of programming aesthetics (which frankly is what we consultants usually do), I wanted something a bit more solid.」とおっしゃっていますね。

美学がどれほど重要だとお考えなのか、興味があります。
私はすでにあるコードをどうにかしなければならないことがほとんどでした。
そういったコードはたいていきちんと設計されていません。
ですから、とても扱いにくいのです。
扱いやすい優れた設計のありがたみが、本当に身に染みて分かりました。
少なくとも、きちんと設計されたソフトウェアは私の仕事を楽しいものにしてくれますからね。
私にとって美学は重要なものなのです。

'''Martin Fowler''': リファクタリングをいつ適用すればよいかという部分で、美学について述べています。私がリファクタリングガイドラインの中で述べたことは、曖昧なものでした。これからは、ただ「Refactor when the code looks ugly」と言うよりも、しっかりとしたガイドラインを提供しようと思っています。たとえば、重複コードは不吉な臭いがするとか、長いメソッドは不吉な臭いがするとか、大きなクラスは不吉な臭いがするとかです。

「不吉な臭い」の多くは表面的なものかもしれません。
プログラムを見ていると、表面的なものばかりに注目してしまいますよね。
たとえば100行のメソッドとかですね。
ですがそれが設計を改善する手助けとなるのです。

100行のメソッドをリファクタリングしていくうちに、
責任の振り分けがうまくいっていないことが原因で
設計がダメになっていることに気付いたりします。
それは、ただメソッドを見ているだけでは分からなかったことかもしれません。
しかし、「100行のメソッドは長い」ということは見ただけで分かります。
表面的な問題が、本当の問題へ導いてくれるわけです。

'''Bill Venners''': 11ページにもおよぶwhile文のあるプロジェクトに携わったことがあります。

'''Martin Fowler''': それはひどいですね。

'''Bill Venners''': ソフトウェアを安定させるために6ヶ月ものタスクを終えた後でも、その11ページのwhile文は存在していました。変更するのが恐ろしかったのです。

'''Martin Fowler''': 11ページものwhile文がひどい設計だということは、すぐに分かります。変更するのが恐ろしいということは、明らかにダメな設計だということですから。



## 優れた設計と生産性(Good Design and Productivity)

'''Bill Venners''': 設計をしっかりやれと言わなくてはいけないのは、そうしないと転職してしまうからではないでしょうか。11ページものwhile文を作った張本人は、我々がそれをキレイにしなくてはならない頃にはすでに会社を去っていました。
プログラマたちは、自分たちのダメな設計を自分たちでどうにかしなくてはならないなんて思っていないのだと思います。
だからこそ、設計に注意を払うインセンティヴが無いのではないでしょうか。
たとえ注意を払ったとしても、設計をしっかりと行うのは難しいですしね。
優れた設計を行うには時間がかかります。
なんだか常に時間のプレッシャーがあるみたいです。

'''Martin Fowler''': きちんと設計されたコードを書くのに時間がかかる、というのに賛成はできません。

'''Bill Venners''': なぜですか？

'''Martin Fowler''': 興味深いことにソフトウェア産業では「よい仕事を行えば、仕事は遅くなる」と思われている節があるようです。コードをよりよく分解しておくよう考えたり、テストを書いたりすると、私は逆にスピードアップしているように思うんですけどね。

設計をきれいにする時間は無駄だと思っているのでしょうか。後から変更するときの時間を今獲得した、今やるほうが簡単だ、とは考えないみたいですね。今やれば、たかだか数分で済むことも、後からやれば何時間もかかるんですけどね。

デバッグの時間を軽視しているようにも思います。
頑固なバグを取るのにどれだけ時間がかかるか、分かっていないみたいです。
テストを行っていればバグがまぎれこんだことはすぐに分かります。
こうすることで、バグがもぐりこんでしまう前にバグフィックスすることが出来ます。
デバッグほどフラストレーションがたまる上に時間が無駄なことはありません。
最初からバグがなかったら、もっともっと早いってことじゃないですか？

## Talk Back!

計画的設計、進化的設計、不吉な臭いについてご意見がありましたら、News & Ideas Forum [Evolutionary Design](http://www.artima.com/forums/flat.jsp?forum=32&thread=2656)で議論しましょう。

----
* [Copyright](http://www.artima.com/copyright.html) (c) 1996-2004 Artima Software, Inc. All Rights Reserved. 
* translator:kdmsnr
