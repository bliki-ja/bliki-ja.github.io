---
title: カプセル化したコレクション
tags: [encapsulation]
---

http://www.martinfowler.com/bliki/EncapsulatedCollection.html

オブジェクト指向の設計を学ぶと、すぐにデータをカプセル化することが重要だと知ることになります。カプセル化のもっとも簡単な形は、アクセッサ(取得や設定のメソッド)を使うことです。言語がサポートするのであればプロパティを使います(クラスの内部からでさえこれを使う人もいます。—[[自己カプセル化|SelfEncapsulation]])。

取得および設定の取り決めは、単一の値に対しては動きますが、値のコレクションのような複数値のフィールドにはうまく働きません。この場合には、他のアクセッサのやり方が必要です。大事な点は、クライアントにはコレクションのデータ構造自体に直接アクセスさせたくないということです。もしそれを許すと、クライアントはデータ保持側が介在することなくそのデータを変更できてしまいます。カプセル化の要点は、オブジェクトがそれ自身のデータを制御することです。

コレクションのフィールドを変更するための方法として、要素をコレクションに追加したり削除したりする特別なメソッドを持たせることがよくあります。従業員のコレクションをもつ{{code(Company)}}クラスがあるとすれば、{{code(addEmployee)}}や{{code(removeEmployee)}}メソッドがあると予想できます。場合によってはコレクションを受け取る {{code(setEmployees)}}メソッドがあるかもしれませんが、これは追加および削除メソッドを使うより簡単です。

一般に、最もややこしいのは取得する側にあります。オブジェクトが保存されている実際のコレクションを返してほしくはありません。でなければ、カプセル化している追加や削除のメソッドを使わずにアイテムの追加、削除が可能になってしまいます。では、何を返してあげるべきでしょうか。最良の選択は、コレクションの上に読み出し専用のビューを置くことです。Javaのコレクションのライブラリでは、変更不可能なコレクション・ラッパを使うことでこれを簡単に行えます。他の選択肢としては、もし可能であれば、裏側にあるコレクションを変更できないイテレータを使うことです。

これらのどちらも使えない場合は、コレクションのコピーを返すことが回答になります。そうすれば、クライアントが変更しても実際のコレクションには影響がありません。コレクションをコピーするのは時間のオーバーヘッドが少しかかりますが、これはオブジェクト参照の集まりでしかなく、重大ではありません。


translated by cept <ceptcept@hotmail.com>
