---
title: ProsAndConsOfLanguageOrientedProgramming
tags: TAGS
---

""※現在、翻訳中です。しばらくお待ちください。

考えてみると、実に様々な形の言語指向プログラミングがポピュラーになっています。
言語指向プログラミングは大まかに2つに分けると便利だと気付きました。
「外部DSL」はアプリケーションのメイン（ホスト）言語とは異なる言語で書かれたもので、
後からコンパイラやインタプリタがメイン言語に変換します。
Unixリトル言語やアクティブデータモデル、そしてXML設定ファイルなどがこのカテゴリに含まれます。
「内部DSL」は、ホスト言語をDSLそのものに変化させたものです。Lispの伝統は、内部DSLの最良の例でしょう。

両者の違いをうまく表すことができる「対」になった言葉が存在しなかったため、
「内部」「外部」という用語をこの記事のために作成しました。
内部DSLは「組み込みDSL（embeded DSLs）」とも呼ばれますが、アプリケーションに組み込まれている言語と混同してしまうため、組み込みという用語を使いたくありませんでした（VBAは外部DSLですが、Wordに「組み込まれて」います）。
ただし、DSLについて書かれたものではよく「組み込み」という用語が使われています。

外部DSLと内部DSLはまったく異なるものですから、それぞれ別々に見ていきましょう。

!!外部DSL 

外部DSLはアプリケーションのメイン言語とは異なる言語で書かれたものです。
先ほどの例では、最後の2つが外部DSLとなります。
Unixリトル言語やXML設定ファイルは外部DSLの良い例です。

外部DSLの長所は、好きなフォーマットを使ってよいという点です。
つまり、読み書き可能な最も簡単なフォーマットを使って、ドメインを表現することができるわけです。
設定ファイルをパースし、実行可能なもの（通常はベースとなる言語になります）を生成するトランスレータを作成できるのであれば、このフォーマットが使用できます。

トランスレータを自分で作成しなければならないということは、短所でもあります。
上記で示したようなシンプルな言語ならばそれほど難しくはありませんが、
複雑な言語になるとトランスレータの作成も難しくなります——ただし、それほど困ることでもありません。
パーサ ジェネレータやコンパイラ コンパイラ ツールを使えば、
非常に複雑な言語を操作することができます。
もちろんDSLもです。DSLは非常にシンプルなものだからです。
XMLはDSLの形式を制限していますが、それでもパースするのは簡単です。

外部DSLの最大の短所は、私が「シンボリック インテグレーション(symbolic integration)」と呼んでいるものが欠けている点です——要は、DSLがベース言語にリンクしていないのです。
ベース言語の環境は我々が行っていることを考慮してはくれません。
プログラミング環境は日に日に精巧になっているため、これはますます問題となっています。

簡単な例として、先ほどの例にあるターゲットクラスのプロパティをリネームしてみましょう。
現代のIDEでは、自動リファクタリング機能でリネームが行えますが、リネームはDSLまでは及びません。
C#の世界とファイルマッピングDSLとの間に、
私が「シンボリック バリア(symbolic barrier)」と呼んでいるものが存在するのです。
マッピングDSLをC#に変換することはできますが、
このバリアがあるために、全てのプログラムを操作することはできません。

このバリアによって、ツールに関する問題がいくつもでてきます。
そもそも、何を使ってDSLをエディットすればよいのでしょうか？
テキスト エディタでも可能ですが、現代のIDEを使ってしまうと、テキスト エディタはもはや原始的な代物に見えてしまいます。
ポップアップリスト、フィールド名の補完、文字が重なってしまったときの赤い波線といった機能が欲しいものです。
しかし、この機能を実現するには、エディタが私のDSLのセマンティックスを理解できなくてはなりません。

セマンティックス エディタはなくても構いませんが、それでは、次にデバッグのことを考えてみましょう。
私のデバッガは変換されたC#であればステップインできますが、
本物のソースにステップインすることはできません。
本当に欲しいのは、私が作ったDSL用の、本格的なIDEです。
テキスト エディタとシンプルなデバッガの時代なら、
これはそれほど大きな問題ではありませんでした。
しかし、我々は「[[PostIntelliJ]]」の世界に生きているのです。

外部DSLに対する反対意見でよくあるのは「言語不協和音」問題です。
言語は習得するのが困難なため、多くの言語を使うのは難しいというのです。
これはDSLを誤解しているのでしょう。
おそらく、複数の汎用言語を想像しているのだと思います。
それだと簡単に不協和音になってしまいます。
しかし、DSLは制限されており、シンプルで、習得が簡単なのです。
これはDSLがドメインに近い存在だからです。
DSLは汎用プログラミング言語とは違います。

基本的に、ある程度のサイズのプログラムでは、抽象的な部分を複数取り扱うことになります。
たとえば、先ほどの例のファイル読み込みのようなところです。
通常、この抽象的な部分はオブジェクトとメソッドを使います。
確かにこれでも動きますが、やりたいことを表現するために制限された文法を使わなくてはなりません（どれくらい制限されるかはベースとなる言語によります）。
一方、外部DSLを使うと、操作しやすい文法にすることができます。
ここで問題となるのは、新しいDSLを理解するコストよりも、外部DSLによって操作が簡単になっている部分が大きいのかという点です。

これについては、DSLの設計の難しさが焦点となります——言語設計は難しく、どんなプロジェクトでも、複数のDSLを設計するのは難しいというわけです。
この反対意見も、DSLではなく汎用言語を前提に考えているのでしょう。
ここで焦点をあてるべきは、どれだけ良い抽象化ができるかということだと思います——これは非常に難しい作業です。
APIの設計とDSLの設計の違いさほどありません——ですから、DSL設計がAPI設計よりも格段に難しいものだとは思いません。

外部DSLが多くの人にとって非常に有益なのは、実行時に評価されるという点です。
つまり、プログラムを再コンパイルせずにパラメータを変更できるのです。
XML設定ファイルがJavaの世界でこんなにもポピュラーになったのは、このためです。
このことは、静的にコンパイルされる言語においては重要な点なのですが、
実行時に式を評価できる言語も多く存在することを覚えておきましょう。
実行時に評価できるな言語にとっては、これはさほど重要なことではありません。
.NETにおけるIronPythonのような、コンパイルタイムとランタイムを混ぜたような言語も出てきています。
IronPythonの内部DSLは、C#システムのコンテキストで評価できます。
これはUnixの世界ではよくあるテクニックで、UnixではC/C++をスクリプト言語でミックスしたりします。

!!内部DSL

内部DSLの長所と短所は、外部DSLのそれをひっくり返したものとなります。
まず、ベース言語とのシンボリック バリアがありません。
ベース言語のパワーと既存のツールのすべてがいつでも使えます。
Lispや適応型オブジェクトモデルが、内部DSLの例です。

内部DSLでよく問題とされるのは、中括弧（｛｝）言語（C、C++、Java、C#）と内部DSLに向いたLispのような言語との間に越えられない壁があるという点です。
内部DSLは、JavaやC#ではなく、LispやSmalltalkに適しています——実際、動的言語の支持者は主な強みとしてこの点を挙げています。
スクリプト言語の世界ではこのことが再認識されています——[[Rubyのメタプログラミング機能|http://poignantguide.net/ruby/chapter-6.html]]や、[[Railsフレームワーク|http://www.rubyonrails.org/]]などを見てください。
この問題は、多くのプログラマが動的言語をちゃんと使ったことがなく、そういった機能（およびその制限）をきちんと理解していないところからきています。

内部DSLはベース言語の構文と構造に制限されます。
動的言語だと制限による制約はそれほどありません。
LispやSmalltalkといったスクリプト言語は最小の構文を持っており、
メインストリームにいる中括弧言語よりもうまく内部DSLを動かせます。
C#とRubyの例を比べてみると、その違いがより明確になるでしょう。
クロージャやマクロのような言語機能も重要です。
こうした機能はCベースの言語には見当たりませんが、それらしき機能はあります。
Annotations（C#でいうattribute）はその良い例でしょう。
このような目的に使うには便利な機能です。

ベース言語にはツールがありますが、ベース言語はDSLがやろうとしていることを知りません——ですから、ツールはDSLを完全にはサポートしていないわけです。
テキスト エディタを使ったほうがいいのかもしれませんが、改良の余地はあります。

DSLで言語のパワーを最大限に引き出すというのは、ありがた迷惑な話です。
ベース言語に精通していれば別にいいのでしょうが、DSLの強みというのは、ベース言語の機能をすべて知らない人でもプログラミングができるという点です——これにより、ドメイン知識を直接システムに取り入れることができます。
内部DSLは、ベース言語に慣れていないとユーザーが混乱する余地が多く、素人プログラマが扱うには難しいものとなっています。

この点については、汎用プログラミング言語用ツールはかず多くあるが、DSLでは限定してツールを使う、というふうにすることができます。
必要以上に多くのツールを用意してしまうと、物事がややこしくなります。
あまり使わないのにツールの習得をしなければならないからです。
理想をいえば、仕事に必要なツールだけあればいいのですが、実際はそれ以上のツールが必要となるでしょう。
（Charles Simonyiはこの考えを[[自由度|http://blog.intentionalsoftware.com/intentional_software/2005/05/notations_and_p.html]]の概念(notion)だと書いています。）

オフィス ツールにも似たようなことがあります。
現代のワープロは使いにくいと文句を言うひとが大勢います。
ひとりの人間では使い切れないほどの多くの機能があるからです。
ただ、こうした機能は誰かに必要とされているのです。
オフィス ツールは巨大なシステムを作って、ユーザー全員を満足させているのです。
各作業に適したツールを複数使うということも考えられるでしょう。
これだと、ツールを習得するのも使うのも、どちらも簡単になります。
問題は、目的に合わせてオフィス ツールを構築すると、コストがかかってしまう点です。
これは、汎用プログラミング言語（および内部DSL）と外部DSLとのトレードオフの関係によく似ています。

内部DSLはプログラミング言語に近いため、プログラミング言語にうまくマップできないものを表すのは難しいと思います。
たとえば、エンタープライズ アプリケーションではレイヤを使うことが多いのですが、
レイヤは通常、プログラミング言語のパッケージで定義されます。そのレイヤ間の依存ルールを定義するのは難しいのです。
つまり、UIコードを{{code('MyApp.Presentation')}}に、ドメインロジックを{{code('MyApp.Domain')}}に入れた場合、DSLには、{{code('MyApp.Domain')}}にあるクラスが{{code('MyAPp.Presentation')}}にあるクラスに触れてはいけないというルールをつける機能がないのです。
これもやはり、汎用言語の限界によるものです——ただし、Smalltalkでは可能です。Smalltalkでは、メタレベルに深くアクセスできますから。

（
比較として、このような動的言語で作られた[[より複雑な例|ALanguageWorkbenchIAction]]は面白いと思います。
私はこれ以上調査することはありませんが、誰かが引き続きやってくれることを願います。その際は、[[LanguageWorkbenchReadings]]で紹介します。
）

!!素人プログラマを巻き込む

外部DSLにせよ内部DSLにせよ「素人プログラマ(lay programmers)」を巻き込めるかどうかが常に話題になります。素人プログラマとは、本職プログラマではないが、開発の一部としてDSLでプログラムするドメイン専門家のことです。
素人プログラマによるプログラミングという目標は、ソフトウェアの世界では昔から変わっていなくて、実際、多くの人たちが初期の高級言語（COBOLやFORTRAN）をユーザーが使うようになれば、プログラマの終焉するなどと思っていました。
私はこれをCOBOLにおける誤った認識という意味で、「COBOL推論(COBOL inference)」と呼んでいます——こういった技術は、本職のプログラマを排除するようなものでは決してないのです。

COBOL推論にも関わらず、何度もユーザーからの入力をプログラムに直接入力しようとします。
プログラムの簡単な部分を切り出し、その部分に限り、ユーザーが安全で快適にプログラムできるようにする方法があります。
そして、そのユーザーがプログラム可能な領域をDSLにするのです。
こういったDSLは非常に洗練されています—— MatLabは非常に複雑なDSLが動いているよい例です。これはドメインにフォーカスしてからこそできるのです。

ユーザー プログラマブルなDSLにおいて、外部DSLの利点というのは、ホスト言語から余分なものをすべて排除できること、そして、ユーザーにとって明快なものを提供できるという点です。制限された構文を持つ言語の場合、この点は問題となります。
しかし、たとえ簡単な言語であっても、内部DSLのほうが問題があります。
DSLのスコープ外だが、言語としては正しい動作を行った場合、ユーザーとってはそれが奇妙な振る舞いや暗号のようなエラーメッセージのように見えてしまい、混乱してしまうでしょう。

言語指向プログラミングの提唱者の多くは、
システムのすべてのドメインロジックがユーザーによって構築されるという
将来像を持っています。
プログラマは必要なサポートツールを作り、ユーザーにプログラムを直接編集およびコンパイルさせるのです。
これはプログラマの終焉を意味するものではありません——必要な数を大幅に削減し（多くのツールは再利用可能）、昨今ソフトウェア開発において停滞気味な数々のコミュニケーション問題を解決するのです。
この素人プログラマビジョンは、非常に魅力的です。
ただし、COBOL推論によるプログラマの終焉は、まだまだ先になりそうです。

以上のことから、素人プログラマによるプログラミングは十分に利用価値があると思います。
ただし、それが言語指向プログラミングのすべてではありません。
たとえユーザプログラマを巻き込まなくとも、良いDSLはプログラマの生産性を向上させるのです。
良いDSLなら、プログラマが使い、ドメイン専門家がレビューすることも可能です。

素人プログラマの議論は大きな賭けです。
もし誰かが、ほとんどすべてをユーザープログラミングに基づいたような技術を正当化するのだとしたら、私はそれを疑うと思います。
今そのようなアプローチが成功したら、それはものすごい効果があると思います。
ただしそれは、プログラマの終焉だからではなく、ドメイン専門家とプログラマのコミュニケーションが改善されるからです。
コミュニケーションの欠如は、ソフトウェアプロジェクトにおける最も大きなバリケードなのです。

!!言語指向プログラミングにおけるトレードオフのまとめ

私にとっての言語指向プログラミングの基本的な問題は、
DSLを使うメリットに対するDSLを効果的に使うための必要なサポート ツールを構築するコストについてです。
内部DSLを使うとツールコストを下げることができます。その反面、DSLを制限することになり、DSLのメリットを格段に下げてしまいます。特に、C言語みたいなのを使っているとそうなります。
一方、外部DSLを使うと、潜在的なベネフィットを得ることができます。
しかし、言語設計やトランスレータの構築、それから、プログラミングをサポートするツールを用意するなど、いろいろとコストがかかります。

これが言語指向プログラミングがあんまり流行らなかった理由だと思います。
内部DSLも外部DSLも、何かしら重大なデメリットがあるわけです。
つまり、今よりDSLを使うようになってもいいのかどうなのか、判断がつきにくいわけですね。

それなら、言語ワークベンチを使うとよいでしょう。
基本的に言語ワークベンチは、外部DSLの柔軟性をセマンティック バリアなしに提供できます。さらにいうと、現代のIDEにマッチしたツールを構築するのが簡単です。
つまり、言語指向プログラミングをより簡単に構築、サポートできるようになり、
言語指向プログラミングを不遇たらしめてきたバリアを低下させることができるのです。
